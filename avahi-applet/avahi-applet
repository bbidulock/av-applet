#!/usr/bin/perl

use Gtk2;
use Gtk2::Notify;
use Net::DBus;
use Net::DBus::GLib;
use Net::Libdnet::Intf;

Gtk2->init;
Gtk2::Notify->init("avahi-applet");

# -----------------------------------------------
package Avahi::Database;
use GDBM_File;
use strict;

our $database;

sub init {
	my $type = shift;
	$database = bless {},$type;
	my %hash;
	my $fn;
	foreach my $f ('/usr/lib/avahi/service-types', '/usr/lib/i386-linux-gnu/avahi/service-types.db') {
		if (-r "$f") { $fn = $f; last; }
	}
	tie %hash, 'GDBM_File', $fn, &GDBM_READER, 0644 if $fn;
	$database->{hash} = \%hash;
}

sub get {
	my ($type,$key) = @_;
	return undef unless $database;
	return undef unless exists $database->{hash}{$key};
	return $database->{hash}{$key};
}

# -----------------------------------------------
package Avahi::Server;
use base qw(Net::DBus::RemoteObject);
use strict;

sub new {
	my $type = shift;
	my $bus = Net::DBus::GLib->system;
	my $service = $bus->get_service("org.freedesktop.Avahi");
	my $self = $service->get_object("/");
	bless $self,$type;
	$self->{my}{bus} = $bus;
	$self->{my}{version} = $self->GetVersionString;
	$self->{my}{apivers} = $self->GetAPIVersion;
	$self->{my}{hostname} = $self->GetHostName;
	$self->{my}{domain} = $self->GetDomainName;
	$self->{my}{fqdn} = $self->GetHostNameFqdn;
	$self->{my}{nsssup} = $self->IsNSSSupportAvailable;
	$self->{my}{state} = $self->GetState;
	$self->{my}{cookie} = $self->GetLocalServiceCookie;
	$self->{my}{local} = Avahi::ServiceTypeBrowser->new($self,"local");
	$self->{my}{browse} = Avahi::DomainBrowser->new($self,"");
	my $sigids = {};
	$sigids->{StateChanged} = $self->connect_to_signal("StateChanged",sub{ $self->StateChanged(@_); });
	$self->{my}{sigids} = $sigids;
	return $self;
}
sub StateChanged {
	my ($self,$state,$err) = @_;
	$self->{my}{state} = $state;
	print $self->get_object_path,": Server error $err\n" if $err;
}
sub destroy {
	my $self = shift;
	delete($self->{my}{local})->destroy;
	delete($self->{my}{browse})->destroy;
	while (my ($name,$sigid) = each %{$self->{my}{sigids}}) {
		$self->disconnect_from_signal($name, $sigid);
	}
}


# -----------------------------------------------
package Avahi::DomainBrowser;
use base qw(Net::DBus::RemoteObject);
use strict;

use constant {
	AVAHI_IF_UNSPEC=>-1,
	AVAHI_PROT_UNSPEC=>-1,
	AVAHI_DOMAIN_UNSPEC=>"",
};

our %domain_browsers;

sub new {
	my ($type,$server,$domain) = @_;
	$domain=AVAHI_DOMAIN_UNSPEC unless $domain;
	print "Calling DomainBrowserNew for domain '$domain'\n";
	my $path = $server->DomainBrowserNew(AVAHI_IF_UNSPEC,AVAHI_PROT_UNSPEC,$domain,0,0);
	my $self = $server->get_service->get_object($path);
	print "Gotone DomainBrowserNew for domain '$domain'\n";
	bless $self,$type;
	$self->{my}{server} = $server;
	$self->{my}{domain} = $domain;
	my $sigids = {};
	$sigids->{AllForNow}      = $self->connect_to_signal("AllForNow",     sub{ $self->AllForNow(@_);      });
	$sigids->{CacheExhausted} = $self->connect_to_signal("CacheExhausted",sub{ $self->CacheExhausted(@_); });
	$sigids->{Failure}        = $self->connect_to_signal("Failure",       sub{ $self->Failure(@_);        });
	$sigids->{ItemNew}        = $self->connect_to_signal("ItemNew",       sub{ $self->ItemNew(@_);        });
	$sigids->{ItemRemove}     = $self->connect_to_signal("ItemRemove",    sub{ $self->ItemRemove(@_);     });
	$self->{my}{sigids} = $sigids;
	$self->{my}{state} = 0;
	print $self->get_object_path,": new for domain '$domain'\n";
	return $self;
}

sub AllForNow {
	my ($self) = @_;
	print $self->get_object_path,": All for now...\n";
}
sub CacheExhausted {
	my ($self) = @_;
	print $self->get_object_path,": Cache exhausted...\n";
	$self->{my}{state} = 1;
	# we could update the screen now
}
sub Failure {
	my ($self,$err) = @_;
	print $self->get_object_path,": Failure: $err\n";
	$self->{my}{state} = -1;
}
sub ItemNew {
	my ($self,$interface,$protocol,$domain,$flags) = @_;
	print $self->get_object_path,": ItemNew\n";
	print "  Interface: $interface\n";
	print "  Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$protocol},"\n";
	print "  Domain: $domain\n";
	print "  Flags: $flags\n";
	unless (exists $domain_browsers{$domain} and
		       $domain_browsers{$domain}) {
		my $server = $self->{my}{server};
		$domain_browsers{$domain} = Avahi::ServiceTypeBrowser->new($server,$domain);
	}
}
sub ItemRemove {
	my ($self,$interface,$protocol,$domain,$flags) = @_;
	print $self->get_object_path,": ItemRemove\n";
	print "  Interface: $interface\n";
	print "  Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$protocol},"\n";
	print "  Domain: $domain\n";
	print "  Flags: $flags\n";
	if (exists $domain_browsers{$domain} and
		   $domain_browsers{$domain}) {
		delete($domain_browsers{$domain})->destroy;
	}
}
sub destroy {
	my $self = shift;
	while (my ($name,$sigid) = each %{$self->{my}{sigids}}) {
		$self->disconnect_from_signal($name, $sigid);
	}
	$self->Free unless $self->{my}{state} == -1;
}
sub cleanup {
	my $type = shift;
	foreach my $svtype (values %domain_browsers) {
		$svtype->destroy;
	}
	%domain_browsers = ();
}

# -----------------------------------------------
package Avahi::ServiceTypeBrowser;
use base qw(Net::DBus::RemoteObject);
use strict;

use constant {
	AVAHI_IF_UNSPEC=>-1,
	AVAHI_PROT_UNSPEC=>-1,
	AVAHI_DOMAIN_UNSPEC=>"",
};

our %svtype_browsers;

sub new {
	my ($type,$server,$domain) = @_;
	return $svtype_browsers{$domain} if exists $svtype_browsers{$domain} and $svtype_browsers{$domain};
	print "Calling ServiceTypeBrowserNew for domain '$domain'\n";
	my $path = $server->ServiceTypeBrowserNew(AVAHI_IF_UNSPEC,AVAHI_PROT_UNSPEC,$domain,0);
	my $self = $server->get_service->get_object($path);
	print "Gotone ServiceTypeBrowserNew for domain '$domain'\n";
	bless $self,$type;
	$self->{my}{server} = $server;
	$self->{my}{domain} = $domain;
	my $sigids = {};
	$sigids->{AllForNow}      = $self->connect_to_signal("AllForNow",     sub{ $self->AllForNow(@_);      });
	$sigids->{CacheExhausted} = $self->connect_to_signal("CacheExhausted",sub{ $self->CacheExhausted(@_); });
	$sigids->{Failure}        = $self->connect_to_signal("Failure",       sub{ $self->Failure(@_);        });
	$sigids->{ItemNew}        = $self->connect_to_signal("ItemNew",       sub{ $self->ItemNew(@_);        });
	$sigids->{ItemRemove}     = $self->connect_to_signal("ItemRemove",    sub{ $self->ItemRemove(@_);     });
	$self->{my}{sigids} = $sigids;
	$self->{my}{state} = 0;
	$self->{my}{browsers} = {};
	$svtype_browsers{$domain} = $self;
	print $self->get_object_path,": new for domain '$domain'\n";
	return $self;
}
sub AllForNow {
	my ($self) = @_;
	print $self->get_object_path,": All for now...\n";
}
sub CacheExhausted {
	my ($self) = @_;
	print $self->get_object_path,": Cache exhausted...\n";
	$self->{my}{state} = 1;
}
sub Failure {
	my ($self,$err) = @_;
	print $self->get_object_path,": Failure: $err\n";
	$self->{my}{state} = -1;
}
sub ItemNew {
	my ($self,$interface,$protocol,$svtype,$domain,$flags) = @_;
	print $self->get_object_path,": ItemNew\n";
	print "  Interface: $interface\n";
	print "  Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$protocol},"\n";
	print "  Type: $svtype\n";
	print "  Domain: $domain\n";
	print "  Flags: $flags\n";
	if (exists $self->{my}{browsers}{$domain}{$svtype}{$protocol} and
		   $self->{my}{browsers}{$domain}{$svtype}{$protocol}) {
		my $item = $self->{my}{browsers}{$domain}{$svtype}{$protocol};
		print "WARNING: ServiceBrowser exists for domain '$domain' type '$svtype' protocol '$protocol'\n";
		print "WARNING: Server: ",$item->{my}{server}->get_object_path,"\n";
		print "WARNING: Domain: $item->{my}{domain} ($domain)\n";
		print "WARNING: Type: $item->{my}{svtype} ($svtype)\n";
		print "WARNING: Protocol: $item->{my}{protocol} ($protocol)\n";
	} else {
		my $server = $self->{my}{server};
		$self->{my}{browsers}{$domain}{$svtype}{$protocol} = Avahi::ServiceBrowser->new($server,$domain,$svtype,$protocol);
	}
}
sub ItemRemove {
	my ($self,$interface,$protocol,$svtype,$domain,$flags) = @_;
	print $self->get_object_path,": ItemRemove\n";
	print "  Interface: $interface\n";
	print "  Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$protocol},"\n";
	print "  Type: $svtype\n";
	print "  Domain: $domain\n";
	print "  Flags: $flags\n";
	if (exists $self->{my}{browsers}{$domain}{$svtype}{$protocol} and
		   $self->{my}{browsers}{$domain}{$svtype}{$protocol}) {
		delete($self->{my}{browsers}{$domain}{$svtype}{$protocol})->destroy;
	}
}
sub destroy {
	my $self = shift;
	foreach my $domain (values %{delete($self->{my}{browsers})}) {
		foreach my $svtype (values %$domain) {
			foreach my $protocol (values %$svtype) {
				$protocol->destroy;
			}
		}
	}
	while (my ($name,$sigid) = each %{$self->{my}{sigids}}) {
		$self->disconnect_from_signal($name, $sigid);
	}
	$self->Free unless $self->{my}{state} == -1;
}
	

# -----------------------------------------------
package Avahi::ServiceBrowser;
use base qw(Net::DBus::RemoteObject);
use strict;

use constant {
	AVAHI_IF_UNSPEC=>-1,
	AVAHI_PROT_UNSPEC=>-1,
	AVAHI_DOMAIN_UNSPEC=>"",
};

our %service_browsers;
our %services;
our %interfaces;
our %hosts;

sub new {
	my ($type,$server,$domain,$svtype,$protocol) = @_;
	if (exists $service_browsers{$domain}{$svtype}{$protocol} and
		   $service_browsers{$domain}{$svtype}{$protocol}) {
		my $item = $service_browsers{$domain}{$svtype}{$protocol};
		print "WARNING: ServiceBrowser already exists for domain '$domain' svtype '$svtype' protocol '$protocol'\n";
		print "WARNING: Server: ",$item->{my}{server}->get_object_path,"\n";
		print "WARNING: Domain: $item->{my}{domain} ($domain)\n";
		print "WARNING: Type: $item->{my}{svtype} ($svtype)\n";
		print "WARNING: Protocol: $item->{my}{protocol} ($protocol)\n";
		return $item;
	}
	print "Calling ServiceBrowserNew for domain '$domain' type '$svtype' protocol '$protocol'\n";
	my $path = $server->ServiceBrowserNew(AVAHI_IF_UNSPEC,$protocol,$svtype,$domain,0);
	my $self = $server->get_service->get_object($path);
	print "Gotone ServiceBrowserNew for domain '$domain' type '$svtype' protocol '$protocol'\n";
	bless $self,$type;
	$self->{my}{server} = $server;
	$self->{my}{domain} = $domain;
	$self->{my}{svtype} = $svtype;
	$self->{my}{protocol} = $protocol;
	my $sigids = {};
	$sigids->{AllForNow}      = $self->connect_to_signal("AllForNow",     sub{ $self->AllForNow(@_);      });
	$sigids->{CacheExhausted} = $self->connect_to_signal("CacheExhausted",sub{ $self->CacheExhausted(@_); });
	$sigids->{Failure}        = $self->connect_to_signal("Failure",       sub{ $self->Failure(@_);        });
	$sigids->{ItemNew}        = $self->connect_to_signal("ItemNew",       sub{ $self->ItemNew(@_);        });
	$sigids->{ItemRemove}     = $self->connect_to_signal("ItemRemove",    sub{ $self->ItemRemove(@_);     });
	$self->{my}{sigids} = $sigids;
	$service_browsers{$domain}{$svtype}{$protocol} = $self;
	print $self->get_object_path,": new for domain '$domain', type '$svtype', protocol '$protocol'\n";
	return $self;
}
sub AllForNow {
	my ($self) = @_;
	print $self->get_object_path,": All for now...\n";
}
sub CacheExhausted {
	my ($self) = @_;
	print $self->get_object_path,": Cache exhausted...\n";
	$self->{my}{state} = 1;
}
sub Failure {
	my ($self,$err) = @_;
	print $self->get_object_path,": Failure: $err\n";
	$self->{my}{state} = -1;
}
sub ItemNew {
	my $self = shift;
	my ($interface,$protocol,$name,$svtype,$domain,$flags) = @_;
	print $self->get_object_path,": ItemNew\n";
	print "  Interface: $interface\n";
	print "  Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$protocol},"\n";
	print "  Name: $name\n";
	print "  Type: $svtype\n";
	print "  Domain: $domain\n";
	print "  Flags: $flags\n";
	my $key = join(':',@_);
	if (exists $services{$key} and $services{$key}) {
		print "WARNING: Service already exists for key '$key'\n";
	} else {
		my $server = $self->{my}{server};
		my $service = Avahi::Service->new($server,@_);
		$services{$key} = $service;
		my $iname = $service->{my}{iname};
		unless (exists $interfaces{$iname} and
			       $interfaces{$iname}) {
			$interfaces{$iname} = Avahi::Interface->new($iname);
		}
		my $host = $service->{my}{host};
		unless (exists $hosts{$interface}{$host} and
			       $hosts{$interface}{$host}) {
			$hosts{$interface}{$host} = Avahi::Host->new($server,$interface,$host);
		}
	}
}
sub ItemRemove {
	my $self = shift;
	my ($interface,$protocol,$name,$svtype,$domain,$flags) = @_;
	print $self->get_object_path,": ItemRemove\n";
	print "  Interface: $interface\n";
	print "  Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$protocol},"\n";
	print "  Name: $name\n";
	print "  Type: $svtype\n";
	print "  Domain: $domain\n";
	print "  Flags: $flags\n";
	my $key = join(':',@_);
	if (exists $services{$key} and
		   $services{$key}) {
		delete($services{$key})->destroy;
	}
}
sub destroy {
	my $self = shift;
	while (my ($name,$sigid) = each %{$self->{my}{sigids}}) {
		$self->disconnect_from_signal($name, $sigid);
	}
	$self->Free unless $self->{my}{state} == -1;
}
sub cleanup {
	my $type = shift;
	%services = ();
	%interfaces = ();
	%hosts = ();
}

# -----------------------------------------------
package Avahi::Service;
use strict;

sub new {
	my ($type,$server,$interface,$protocol,$name,$svtype,$domain,$flags) = @_;
	my $self = {};
	bless $self,$type;
	$self->{my}{server} = $server;
	$self->{my}{interface} = $interface;
	$self->{my}{protocol} = $protocol;
	$self->{my}{name} = $name;
	$self->{my}{type} = $svtype;
	$self->{my}{domain} = $domain;
	$self->{my}{flags} = $flags;
	$self->{my}{iname} = $server->GetNetworkInterfaceNameByIndex($interface);
	my @result = $server->ResolveService($interface,$protocol,$name,$svtype,$domain,-1,0);
	if (@result) {
		$self->{my}{interface} = $result[0];
		$self->{my}{protocol} = $result[1];
		$self->{my}{name} = $result[2];
		$self->{my}{type} = $result[3];
		$self->{my}{domain} = $result[4];
		$self->{my}{host} = $result[5];
		$self->{my}{aprotocol} = $result[6];
		$self->{my}{address} = $result[7];
		$self->{my}{port} = $result[8];
		$self->{my}{txt} = [ map {pack('U*',@$_)} @{$result[9]} ];
		$self->{my}{flags} = $result[10];
	}
	$self->{my}{descrip} = Avahi::Database->get($self->{my}{type});
	print ref($self),": new\n";
	print "  Interface: $self->{my}{interface} ($self->{my}{iname})\n";
	print "  Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$self->{my}{protocol}},"\n";
	print "  Name: $self->{my}{name}\n";
	print "  Type: $self->{my}{type}\n";
	print "  Description: $self->{my}{descrip}\n";
	print "  Domain: $self->{my}{domain}\n";
	print "  Host: $self->{my}{host}\n";
	print "  Alternate protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$self->{my}{aprotocol}},"\n";
	print "  Address: $self->{my}{address}\n";
	print "  Port: $self->{my}{port}\n";
	print "  TXT: ",join(';',@{$self->{my}{txt}}),"\n";
	print "  Flags: $self->{my}{flags}\n";
	if ($self->{my}{type} eq '_ssh._tcp') {
		my $text=<<EOF;
Interface: $self->{my}{interface} ($self->{my}{iname})
Name: $self->{my}{name}
Type: $self->{my}{type}
Description: $self->{my}{descrip}
Host: $self->{my}{host}
Address: $self->{my}{address}
Port: $self->{my}{port}
EOF
		my $notify = Gtk2::Notify->new("Avahi",$text,"gtk-connect");
		$self->{my}{notify} = $notify;
		$notify->add_action('ssh','SSH Connect','Avahi::Service::SSHConnect',$self);
		$notify->set_timeout(0);
		$notify->show;
	}
	return $self;
}

sub SSHConnect {
	my ($notify,$action,$self) = @_;
	print "Arguments are: ",join(',',@_),"\n";
	print "executing (lxterminal -e ssh $self->{my}{address} </dev/null >/dev/null 2>&1) &\n";
	system("(lxterminal -e ssh $self->{my}{address} </dev/null >/dev/null 2>&1) &");
}


# -----------------------------------------------
package Avahi::Interface;
use base qw(Net::Libdnet::Entry::Intf);
use strict;

sub new {
	my ($type,$name) = @_;
	my $self = Avahi::Applet->get_intf($name);
	print ref($self),": new\n";
	print $self->print, "\n";
	bless $self,$type;
	return $self;
}

# -----------------------------------------------
package Avahi::Host;
use strict;

sub new {
	my ($type,$server,$interface,$name) = @_;
	my $self = bless {},$type;
	$self->{interface} = $interface;
	$self->{name} = $name;
	$self->{iname} = $server->GetNetworkInterfaceNameByIndex($interface);
	my @result = $server->ResolveHostName($interface,-1,$name,-1,0);
	if (@result) {
		$self->{interface} = $result[0];
		$self->{protocol} = $result[1];
		$self->{name} = $result[2];
		$self->{aprotocol} = $result[3];
		$self->{address} = $result[4];
		$self->{flags} = $result[5];
	}
	print ref($self),": new\n";
	print " Interface: $self->{interface} ($self->{iname})\n";
	print " Protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$self->{protocol}},"\n";
	print " Name: $self->{name}\n";
	print " Alternate protocol: ",{-1=>"unspecified",0=>"IPv6",1=>"IPv4"}->{$self->{aprotocol}},"\n";
	print " Address: $self->{address}\n";
	print " Flags: $self->{flags}\n";
	return $self;
}

# -----------------------------------------------
package Avahi::Notify;
use base qw(Gtk2::Notify);
use strict;

sub new {
	my ($type,$icon) = @_;
	my $self = Gtk2::Notify->new("Avahi","Avahi notification","gtk-connect");
	$self->signal_connect_swapped('closed'=>\&Avahi::Notify::closed,$self);
	bless $self,$type;
	$self->{my}{state} = 0;
	$self->show;
	return $self;
}
sub closed {
	my ($self,$notify) = @_;
	$self->{my}{state} = 0;
	return Gtk2::EVENT_PROPAGATE;
}

# -----------------------------------------------
package Avahi::Icon;
use base qw(Gtk2::StatusIcon);
use strict;

sub new {
	my $type = shift;
	my $self = Gtk2::StatusIcon->new_from_stock('gtk-connect');
	$self->{my}{notify} = Avahi::Notify->new($self);
	$self->set_tooltip_text('Avahi applet.');
	$self->set_visible(1);
	$self->signal_connect_swapped(button_press_event=>
			\&Avahi::Icon::button_press_event,$self);
	$self->signal_connect_swapped(button_release_event=>
			\&Avahi::Icon::button_release_event,$self);
	$self->signal_connect_swapped(scroll_event=>
			\&Avahi::Icon::scroll_event,$self);
	$self->signal_connect_swapped(query_tooltip=>
			\&Avahi::Icon::query_tooltip,$self);
	$self->signal_connect_swapped(popup_menu=>
			\&Avahi::Icon::popup_menu,$self);
	$self->signal_connect_swapped(activate=>
			\&Avahi::Icon::activate,$self);
	$self->signal_connect_swapped(size_changed=>
			\&Avahi::Icon::size_changed,$self);
	bless $self,$type;
	return $self;
}
sub button_press_event {
	my ($self,$event,$icon) = @_;
#print "button-press-event: ",join(', ',@_),"\n";
#print "Button pressed!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub button_release_event {
	my ($self,$event,$icon) = @_;
#print "button-release-event: ",join(', ',@_),"\n";
#print "Button released!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub scroll_event {
	my ($self,$event,$icon) = @_;
#print "scroll-event: ",join(', ',@_),"\n";
#print "Scroll!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub query_tooltip {
	my ($self,$x,$y,$bool,$tooltip,$icon) = @_;
print "query-tooltip: ",join(', ',@_),"\n";
print "Tooltip query!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub popup_menu {
	my ($self,$button,$time,$icon) = @_;
	print "popup-menu: ",join(', ',@_),"\n";
	print "Popup menu!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub activate {
	my ($self,$icon) = @_;
	print "activate: ",join(', ',@_),"\n";
	print "Activated!\n";
	return Gtk2::EVENT_PROPAGATE;
}
sub size_changed {
	my ($self,$pixels,$icon) = @_;
#print "size-changed: ",join(', ',@_),"\n";
#print "Size changed to $pixels!\n";
	return Gtk2::EVENT_PROPAGATE;
}

# -----------------------------------------------
package Avahi::Applet;
use strict;

our $applet;

sub init {
	my $type = shift;
	return if $applet;
	$applet = bless {},$type;
	$applet->{icon} = new Avahi::Icon;
	$applet->{server} = new Avahi::Server;
	$applet->{intf} = new Net::Libdnet::Intf;
	return;
}

sub get_intf {
	my ($type,$name) = @_;
	return $applet->{intf}->get($name);
}

# -----------------------------------------------
package main;
use strict;

Avahi::Database->init;
Avahi::Applet->init;

Gtk2->main;
